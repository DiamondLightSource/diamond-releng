# For a single git repo, clean it, update from the remote origin, and make sure it is checked out on the standard branch (as previously determined)
# If there are any problems with the repo, delete it, and do not re-clone (Buckminster, or the scripts generated by identify_changes_to_test.py, will clone it later)
# This just gets the standard branches, and is run BEFORE the scripts generated by identify_changes_to_test.py
# WARNING: this function can be invoked from xargs, so it needs to be able to run in parallel

#------------------------------------#
#------------------------------------#

update_single_git_repo_function () {
    # parameter 1 - absolute path to git repository to process

    local repo_path=$1
    local repo_name=$(basename ${repo_path})
    echo "Clean and reset of ${repo_name} started"

    # Save xtrace state (1=was not set, 0=was set)
    if [[ $- = *x* ]]; then
        oldxtrace=0
    else
        oldxtrace=1
    fi
    set +x  # Turn off xtrace

    # Save errexit state (1=was not set, 0=was set)
    if [[ $- = *e* ]]; then
        olderrexit=0
    else
        olderrexit=1
    fi
    set -e  # Turn on errexit

    if [[ ! -d "${repo_path}/.git" ]]; then
        echo "Problems with ${repo_name}; ${repo_path}/.git missing, so deleting"
        ls -ld ${repo_path} || true
        rm -rf ${repo_path}
        return
    fi

    # abort any prior failed operation
    git -C ${repo_path} rebase --abort > /dev/null 2>&1 || true
    git -C ${repo_path} merge --abort > /dev/null 2>&1 || true

    # Save pipefail state (1=was not set, 0=was set)
    if [[ $- = *e* ]]; then
        oldpipefail=0
    else
        oldpipefail=1
    fi
    set -o pipefail  # Turn on pipefail

    # If a previous job left any git repository in an inconsistent state (e.g. due to network problems), delete the repository
    # Prior to git 2.6.0, git fsck could have an exit code of zero even if errors were found, so check stderr as well as the exit code (next 2 lines require pipefail)
    # As of git 2.6.0+, this was supposed to have been fixed, but retain the check of stderr anyhow

    # As of git 2.6.0+, git fsck can be told to ignore certain errors. Our convention is that to use this, we put a file called .git.fsck.skiplist in the repo root directory
    if [[ -f "${repo_path}/.git.fsck.skiplist" ]]; then
        git -C ${repo_path} config fsck.skiplist ".git.fsck.skiplist"
        git -C ${repo_path} config --list | grep fsck
    fi

    ERRORS=$(git -C ${repo_path} fsck --no-progress --full --strict 2>&1 | wc -l | cut -d ' ' -f 1)
    RETVAL=$?
    if [[ "${RETVAL}" == "0" && "${ERRORS}" == "0" ]]; then
        git -C ${repo_path} reset --quiet --hard HEAD && git -C ${repo_path} clean -fdxq
        RETVAL=$?
    fi
    if [[ "${RETVAL}" == "0" && "${ERRORS}" == "0" ]]; then
        git -C ${repo_path} fetch --prune |& sed "s/^/[${repo_name}] /"
        RETVAL=$?
    fi
    if [[ "${RETVAL}" != "0" || "${ERRORS}" != "0" ]]; then
        echo "Problems with structure or state of ${repo_path}, so deleting"
        ls -ld ${repo_path} || true
        rm -rf ${repo_path}
        return
    fi

    # At this point, the repository is clean, and up-to-date with the remote. We need to re-establish the correct local branch.
    # We cannot assume that the local branch is tracking the standard branch, since this might be a Gerrit repository previously used to test a change
    repo_branch=$(grep "${repo_name%.git}" ${WORKSPACE}/artifacts_to_archive/cquery-branches-file.txt | head -n 1 | cut -d "=" -f 2)
    git -C ${repo_path} checkout --detach --quiet
    git -C ${repo_path} branch -D --quiet ${repo_branch} || true
    git -C ${repo_path} checkout -b ${repo_branch} remotes/origin/${repo_branch} --no-track --quiet
    echo "Clean and reset of ${repo_name} completed"

    $([ "$oldpipefail" == "0" ]) && set -o pipefail || true  # Turn pipefail on if it was on at the top of this script
    $([ "$oldpipefail" == "1" ]) && set +o pipefail || true  # Turn pipefail off if it was off at the top of this script
    $([ "$olderrexit" == "0" ]) && set -e || true  # Turn errexit on if it was on at the top of this script
    $([ "$olderrexit" == "1" ]) && set +e || true  # Turn errexit off if it was off at the top of this script
    $([ "$oldxtrace" == "0" ]) && set -x || true  # Turn xtrace on if it was on at the top of this script
    $([ "$oldxtrace" == "1" ]) && set +x || true  # Turn xtrace off if it was off at the top of this script

}

export -f update_single_git_repo_function

#------------------------------------#
#------------------------------------#

